# Strings

### Why are strings immutable in java?

Immutable objects are objects which once declared elements can’t be modified after it.

A String in Java that is specified as immutable, as the content shared storage in a single pool to minimize creating a
copy of the same value.

These are some more reasons for making String immutable in Java. These are:

* The String pool cannot be possible if String is not immutable in Java. A lot of heap space is saved by JRE. The same
  string variable can be referred to by more than one string variable in the pool. String interning can also not be
  possible if the String would not be immutable.
* If we don’t make the String immutable, it will pose a serious security threat to the application. For example,
  database usernames, and passwords are passed as strings to receive database connections. The socket programming host
  and port descriptions are also passed as strings. The String is immutable, so its value cannot be changed. If the
  String doesn’t remain immutable, any hacker can cause a security issue in the application by changing the reference
  value.
* The String is safe for multithreading because of its immutableness. Different threads can access a single “String
  instance”. It removes the synchronization for thread safety because we make strings thread-safe implicitly.
* Immutability gives the security of loading the correct class by Classloader. For example, suppose we have an instance
  where we try to load java.sql.Connection class but the changes in the referenced value to the myhacked.The connection
  class does unwanted things to our database.

---

### How intern() works?

[Check Usage](howinternworks/HowInternWorks.java)

The intern() method creates an exact copy of a string located in the heap memory and stores it in the string constant
pool.


---

### How many objects are created in Strings using string literals and new operator?

```
String s = "TEST" - 1 Object
String s = new String("TEST") - 2 Objects
```

---

### How string constant pool works?

A Java String Pool is a place in heap memory where all the strings defined in the program are stored. Whenever we create
a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool,
the same object reference is shared with the variable, else a new object is created.

[Check Usage](stringconstantpool/StringConstantPool.java)

When a new keyword is used to create the strings, Java creates it in a separate memory location and hence when comparing
s1 & s2 returns false.

When we use a literal to create the strings, JVM checks if the string is already present in the String Constant Pool
while creating s3. When it's not able to find it, it creates it in the pool. Now, when we initialized s4 with the same
value, upon checking for it in the pool, it finds it (s3), and references s4 to s3. Hence, when we compare s3 to s4, it
returns true.

---

### Difference between equals and == operator?

[Check Usage](stringconstantpool/StringConstantPool.java)

The string equals() method compares two strings and returns true if all characters match in both strings, else returns
false. The == operator compares the reference or memory location of objects in a heap, whether they point to the same
location or not.

---

### Difference between string, string buffer and string builder.

String is immutable whereas StringBuffer and StringBuilder are mutable classes. StringBuffer is thread-safe and
synchronized whereas StringBuilder is not. That's why StringBuilder is faster than StringBuffer.

---

# Objects

### Why is wrapper class required?

A wrapper class wraps (encloses) around a data type and gives it an object appearance. Wrapper classes are final and
immutable.

Feature:

* Wrapper Classes provides additional features over the primitive data types when it comes to usage. These methods
  include primarily methods like valueOf(), parseInt(), toString(), and many more.
* An object is needed to support synchronization in multithreading.
* Data structures in the Collection framework, such as ArrayList and Vector, store only objects (reference types) and
  not primitive types.

Boxing or AutoBoxing is the process of converting a primitive datatype into an object wrapper datatype, and unboxing is
the process of converting a value from an object wrapper type back to the native primitive value.

---

### Methods of Object class?

Following are the methods present in the Object Class:

* **toString()** - This method obtains the object’s string representation, offering flexibility for customization.
* **hashCode()** - A hash code is a numeric value generated by a specific method known as a hashing algorithm. In Java,
  every object possesses a distinct and unique hash code. This code is derived by applying the algorithm to the internal
  address of the object.
* **equals()** - This method compares two objects and indicates whether they are equal or not.
* **get()** - Java’s get() function, associated with objects, retrieves the value of a designated field represented by a
  Field object.
* **finalize()** - The garbage collector triggers the finalize() method when removing an object from memory,
  specifically
  when there are no remaining references to that object.
* **clone()** - In a subclass that implements the Cloneable Interface, it is expected to override the clone() method of
  the
  Object class. This method is utilized for creating a clone, essentially a duplicate of the object along with its
  member variable values, using the syntax obj.clone(). If a class fails to implement the Cloneable interface,
  attempting this process results in a thrown CloneNotSupportedException.
* **wait()** - By using this technique, the current thread is made to wait for a notification from another thread.
  Within the function, you must provide the time in milliseconds for which the thread will remain in this waiting state.
* **notify()** - By using this technique, notifications are sent to a single thread at a time, waking it up while it is
  waiting for a certain item.
* **notifyAll()** - This function awakens all threads that are currently waiting for an object and sends notifications
  to all threads at the same time.

---

### Does java gives importance to primitive data types?

Java has a two-fold type system consisting of primitives such as int, boolean and reference types such as Integer,
Boolean. Every primitive type corresponds to a reference type.

Every object contains a single value of the corresponding primitive type. The wrapper classes are immutable (so that
their state can’t change once the object is constructed) and are final (so that we can’t inherit from them).

Variables of primitive types live in the stack and hence are accessed **fast**. For the details, we recommend our
tutorial
on the Java memory model whereas, The reference types are objects, they live on the heap and are relatively slow to
access.
They have a certain overhead concerning their primitive counterparts.

Default values of the primitive types are 0 (in the corresponding representation, i.e. 0, 0.0d etc) for numeric types,
false for the boolean type, \u0000 for the char type. For the wrapper classes, the default value is null.

Current Java language specification doesn’t allow usage of primitive types in the parametrized types (generics)

[More details from here](https://www.baeldung.com/java-primitives-vs-objects)

### Is Java pass by value or pass by reference?

Pass By Value - Java creates a copy of the variable being passed in the method and then do the manipulations.

[Example](javapassbyvalue/JavaPassByValue.java)

---

# OOPS

### Types of oops

* **Abstraction** - Abstraction is the process of hiding the internal details of an application from the outer world.
  Abstraction is used to describe things in simple terms. It’s used to create a boundary between the application and the
  client programs. In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction
  using interfaces.

* **Encapsulation** - It refers to the bundling of data with the methods that operate on that data. Encapsulation is
  used to hide the values or state of a structured data object inside a class, preventing unauthorized parties' direct
  access to
  them.

* **Inheritance** - It is the mechanism in Java by which one class is allowed to inherit the features (fields and
  methods) of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as “is-a”
  relationship.

* **Polymorphism** - The ability of objects to take on many forms. In other words, it allows different objects to
  respond to the same message or method call in multiple ways. Method Overloading & Method Overriding Are used to
  achieve this.

**Method Overriding:** In Java, method overriding occurs when a subclass (child class) has the same method as the parent
class. In other words, method overriding occurs when a subclass provides a particular implementation of a method
declared by one of its parent classes.

**Method Overloading:** Method overloading in Java means having two or more methods (or functions) in a class with the
same name and different arguments (or parameters).
---

### Composition vs Aggregation vs Association?

If an object contains the other object and the contained object cannot exist without the existence of that object, then
it is called **composition**. It represents part-of relationship. In composition, both entities are dependent on each
other.

**Association** in Java is a connection or relation between two separate classes that are set up through their objects.
Association relationship indicates how objects know each other and how they are using each other's functionality. It can
be one-to-one, one-to-many, many-to-one, and many-to-many.

**Aggregation** is a type of association between classes in which one class (the whole or container) contains a
reference to another class (the part or component). Aggregation represents a “has-a” relationship, where one class
contains objects of another class as part of its internal structure.

[Details & Examples Here](https://www.geeksforgeeks.org/association-composition-aggregation-java/)

---

### Difference between Abstract class and Interface?

**Abstract Class**

An abstract class is a class that cannot be instantiated on its own and may contain both abstract methods (without a
body) and concrete methods (with a body). Abstract classes are used to provide a common base class for other classes to
extend from.

Key Characteristics:

* Abstract Methods: Can have abstract methods that must be implemented by subclasses.
* Concrete Methods: Can have concrete methods with a body.
* Fields: Can have fields (variables) and constructors.
* Access Modifiers: Methods and fields can have different access modifiers (public, protected, private).
* Single Inheritance: A class can extend only one abstract class.

It is not mandatory to provide an access modifier to an abstract class. However, if you do not specify an access
modifier, the default access level will be package-private (i.e., accessible only within the same package).

**Interfaces**

An interface is a reference type in Java, similar to a class, that can contain only constants, method signatures,
default methods, static methods, and nested types. Interfaces cannot contain instance fields or constructors. Interfaces
are used to define a contract that other classes must follow.

Key Characteristics:

* Abstract Methods: All methods are implicitly abstract (except default and static methods).
* Default Methods: Can have default methods with a body.
* Static Methods: Can have static methods with a body.
* No Fields: Cannot have instance fields, but can have static final constants.
* Multiple Inheritance: A class can implement multiple interfaces.

By default, all the methods in an interface are public and abstract, and all the fields are public, static, and final

[Demo](abstractclassesandinterfaces)

---

### Can private method or static methods be overridden in Java?

No, we cannot override private or static methods in Java.

Private methods in Java are not visible to any other class which limits their scope to the class in which they are
declared.

If a method is declared as static, it is a member of a class rather than belonging to the object of the class. It can be
called without creating an object of the class. A static method also has the power to access static data members of the
class.

---

### Can main() method be overloaded?

Yes, we can overload the main() method in Java. A Java class can have any number of overloaded main() methods. But the
very first thing JVM (Java Virtual Machine) seeks is the original main() method, i.e., public static void main(String[]
args) to execute.

---

### Can Abstract Classes and Interfaces have main() ?

Abstract Classes can have main()

Interfaces has 2 answers :)

No you cannot, because main has to be static in order to be used as an entry point, and Interfaces don't allow the use
of static, till Java 7

Yes you can run a psvm in an interface, if you're working in Java 8. Because static methods are allowed in an interface
starting from Java 8.

# Serialization

### What is Serialisation and Deserialization?

Data **serialization** is the process of converting an object into a stream of bytes to more easily save or transmit it.

Constructing a data structure or object from a series of bytes is **deserialization**.

---

### Use of transient keyword?

The primary role of the transient keyword comes in cases of serialization. The transient modifier can be applied to
field members of a class to turn off serialization on these specific members.

---

### Is it possible to serialise a class if its super class is not serializable ?Can the class be still serialised and deserialize?

Yes provided that non-serializable super class has no args constructor which is involved at deserialization to
initialise the super class.

How it works ?

**Serialization of the Serializable Subclass:**

* When you serialize an instance of the subclass, only the fields declared in the subclass and the serializable parts of
  the object graph are serialized.
* The non-serializable superclass is not serialized, but its default (no-arg) constructor will be called during
  deserialization to initialize the state inherited from the superclass.

**Deserialization Process:**

* During deserialization, the non-serializable superclass is reinitialized using its default constructor.
* If the non-serializable superclass does not have a default constructor, deserialization will fail.

# Cloning

### What is marker interface?

An interface that does not contain methods, fields, and constants is known as marker interface. The Serializable and
Cloneable interfaces are the example of marker interface.

By introducing annotations, Java provided us with an alternative to achieve the same results as the marker interfaces.
Moreover, like marker interfaces, we can apply annotations to any class, and we can use them as indicators to perform
certain actions.

So what’s the key difference?

Unlike annotations, interfaces allow us to take advantage of polymorphism. As a result, we can add additional
restrictions to the marker interface.

---

### What is shallow copy and Deep copy?

Shallow Copy stores the references of objects to the original memory address. And so, Shallow Copy reflects changes made
to the new/copied object in the original object. Hence, A shallow copy is faster.

Deep copy truly clones the underlying data. It is not shared between the first and therefore the copy. Therefore, Deep
copy doesn’t reflect changes made to the new/copied object in the original object.

# Exception

### Errors vs Exceptions

Errors indicate unrecoverable system issues beyond program control. In contrast, exceptions represent unexpected events
within the program that can often be handled gracefully.

---

### Checked Vs Unchecked Exception

Checked exceptions represent errors outside the control of the program. For example, the constructor of FileInputStream
throws FileNotFoundException if the input file does not exist. Some common checked exceptions in Java are IOException,
SQLException and ParseException. Java verifies checked exceptions at compile-time.

If a program throws an unchecked exception, it reflects some error inside the program logic. For example, if we divide a
number by 0, Java will throw ArithmeticException. Java does not verify unchecked exceptions at compile-time.

---

### Create Custom Exception

[CreateCustomException](CreateCustomException.java)

---

### What is Runtime exception ?

A runtime exception is an error that occurs while a program is running. Unlike compile-time errors, which are caught by
the compiler before the program runs, runtime exceptions happen during the execution of the program. These exceptions
typically arise due to unexpected conditions or incorrect usage of programming constructs, such as dividing by zero,
accessing an array element out of bounds, or attempting to use a null reference.

---

### How does JVM handle Exception?

The JVM is responsible for finding an exception handler to process the Exception object. It searches backward through
the call stack until it finds a matching exception handler for that particular class of Exception object (in Java term,
it is called " catch " the Exception ).

When the JVM doesn't find a handler, it resorts to its default exception handling mechanism, which involves printing the
exception information to the console and terminating the program. This behavior helps developers identify and diagnose
runtime errors in their Java programs.

---

### Difference between Final, Finalise and Finally?

[Javapoint Article](https://www.javatpoint.com/difference-between-final-finally-and-finalize)

---

### Super class of all exceptions?

Throwable class

[Exception Hierarchy In java](https://www.javamex.com/tutorials/exceptions/ExceptionHierarchy.png)

---

### When Finally block doesn’t get executed?

The finally block may not execute if the JVM exits while the try or catch code is being executed.

---

### Can subclass throw higher checked exception than base class?

Subclasses can throw fewer checked exceptions than their superclass, but not more.

---

### Can we throw an unchecked exception in child class if parent class doesn’t throw any exception?

Yes, you can throw unchecked exceptions in a subclass even if the parent class does not declare any exceptions.
Unchecked exceptions, such as those that subclass RuntimeException or Error, do not need to be declared in the method
signature using the throws clause.

When you override a method in a subclass, you are allowed to throw unchecked exceptions regardless of whether the
superclass method declares any exceptions or not. This is because unchecked exceptions are not subject to the same rules
as checked exceptions in Java.

---

### Difference between throw and throws()

The Throw keyword is used inside a method. Whereas the Throws keyword is used in the method signature. The Throw keyword
throws an exception explicitly. Whereas the Throws keyword declares that a method might throw an exception.

# Enums

### Why to use Enum?

You should use enum types any time you need to represent a fixed set of constants.

Enums improve the readability of your code by providing meaningful names for constants. Instead of using arbitrary
integers or strings to represent different states or options, you can use descriptive enum values. This makes your code
easier to understand and maintain

Type Safety: Enums provide type safety, meaning that the compiler can enforce the use of valid enum values at compile
time. This helps catch errors early in the development process, reducing the likelihood of runtime errors related to
incorrect constant values.

# Garbage collection

### How does Garbage collection in Java works?

During the garbage collection process, the collector scans different parts of the heap, looking for objects that are no
longer in use. If an object no longer has any references to it from elsewhere in the application, the collector removes
the object, freeing up memory in the heap.

# Collections

### Array vs ArrayList

In Java, an ArrayList is used to represent a dynamic list. While Java arrays are fixed in size (the size cannot be
modified), an ArrayList allows flexibility by being able to both add and remove elements.

[Javapoint Article](https://www.javatpoint.com/difference-between-array-and-arraylist)

### ArrayList vs LinkedList? When to use which collection?

ArrayList is a resizable array implementation of the List interface. It provides a dynamic array that can grow as
needed. Elements can be accessed directly by their index in constant time (O(1)), but adding or removing elements,
particularly in the middle of the list, may require shifting elements and thus can take linear time (O(n)).

LinkedList is a doubly-linked list implementation of the List and Deque interfaces. It consists of nodes where each node
contains a reference to the previous and next node in the sequence. This structure allows for constant-time (O(1))
insertions and deletions from the beginning or middle of the list but requires linear time (O(n)) for accessing elements
by index.

**Scenario Where ArrayList is Better than LinkedList**

Use Case: Frequent Random Access

Example: You have a list of student records, and you frequently need to access records by their index, such as
displaying the record of the 1000th student.

**Scenario Where LinkedList is Better than ArrayList**

Use Case: Frequent Insertions/Deletions in the Middle of the List

Example: You have a to-do list where tasks are frequently added or removed from various positions in the list (e.g.,
inserting a high-priority task at the beginning or removing a completed task from the middle).

---

### Fail Safe vs Fail Fast Iterators?

**Fail-fast** iterators immediately throw a ConcurrentModificationException if the underlying collection is modified (
except
through the iterator's own remove method) while iterating over it.

Most of the Java Collections Framework classes like ArrayList, HashSet, HashMap, etc., provide fail-fast iterators.

**Fail-safe** iterators do not throw any exceptions if the collection is modified during iteration. Instead, they work
on a
clone of the collection, meaning modifications to the collection will not be reflected in the iterator.

Collections from the java.util.concurrent package, such as ConcurrentHashMap, CopyOnWriteArrayList, etc.


---

### Concurrent Modification Exception ?

ConcurrentModificationException is thrown when a collection is structurally modified (modification that changes the size
of the collection or affects its internal structure) while it is being iterated over, and this modification is not made
through the iterator itself.

```
import java.util.ArrayList;
import java.util.Iterator;

ArrayList<String> list = new ArrayList<>();
list.add("one");
list.add("two");

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
    list.add("three");  // Modifying the collection directly
}

```

In this example, the modification (list.add("three")) occurs during iteration, causing a
ConcurrentModificationException.

---

### Internal working of HashMap

**Concepts**

* Hash Function:
    * A HashMap uses a hash function to compute an index (also called hash code) for each key.
    * This index determines where the key-value pair will be stored in the internal array (called the table) of the
      HashMap.
* Buckets:
    * The internal array of a HashMap consists of buckets.
    * Each bucket can hold one or more key-value pairs.
    * The index from the hash function maps to a specific bucket.
* Nodes:
    * Each element in the bucket is stored in a node.
    * A node typically contains four fields: key, value, hash, and a reference to the next node (used for handling
      collisions).
* Handling Collisions:
    * Collisions occur when multiple keys hash to the same index.
    * HashMap handles collisions using a linked list or a balanced tree (since Java 8).
    * When a bucket contains multiple nodes (due to collisions), these nodes are stored in a linked list.
    * If the number of nodes in a bucket exceeds a certain threshold (TREEIFY_THRESHOLD, usually 8), the linked list is
      converted to a balanced tree (usually a red-black tree) to improve performance.

When a HashMap is created, an internal array (table) is initialized.

**When a key-value pair is added using put(K key, V value):**

* The hash function is applied to the key to compute the hash code.
* The hash code is then used to determine the index in the table.
* If the bucket at the computed index is empty, a new node is created and placed in that bucket.
* If the bucket is not empty, a linear search is performed in the linked list (or tree) for the node with the same key.
    * If a node with the same key is found, the value is updated.
    * If no such node is found, a new node is added to the linked list (or tree).

**When retrieving a value using get(Object key):**

* The hash function is applied to the key to compute the hash code.
* The hash code is used to find the index in the table.
* The linked list (or tree) at the computed index is searched for the node with the given key.
* If the node is found, its value is returned.
* If no such node is found, null is returned.

**When removing a key-value pair using remove(Object key):**

* The hash function is applied to the key to compute the hash code.
* The hash code is used to find the index in the table.
* The linked list (or tree) at the computed index is searched for the node with the given key.
* If the node is found, it is removed from the linked list (or tree).
* The removed node's value is returned.

[Representation of the internal working of a hashmap](https://miro.medium.com/v2/resize:fit:720/format:webp/0*8R3e49BbAuMEJhrx.jpg)