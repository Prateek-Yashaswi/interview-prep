# Strings

### Why are strings immutable in java?

Immutable objects are objects which once declared elements can’t be modified after it.

A String in Java that is specified as immutable, as the content shared storage in a single pool to minimize creating a
copy of the same value.

These are some more reasons for making String immutable in Java. These are:

* The String pool cannot be possible if String is not immutable in Java. A lot of heap space is saved by JRE. The same
  string variable can be referred to by more than one string variable in the pool. String interning can also not be
  possible if the String would not be immutable.
* If we don’t make the String immutable, it will pose a serious security threat to the application. For example,
  database usernames, and passwords are passed as strings to receive database connections. The socket programming host
  and port descriptions are also passed as strings. The String is immutable, so its value cannot be changed. If the
  String doesn’t remain immutable, any hacker can cause a security issue in the application by changing the reference
  value.
* The String is safe for multithreading because of its immutableness. Different threads can access a single “String
  instance”. It removes the synchronization for thread safety because we make strings thread-safe implicitly.
* Immutability gives the security of loading the correct class by Classloader. For example, suppose we have an instance
  where we try to load java.sql.Connection class but the changes in the referenced value to the myhacked.The connection
  class does unwanted things to our database.

---

### How intern() works?

[Check Usage](howinternworks/HowInternWorks.java)

The intern() method creates an exact copy of a string located in the heap memory and stores it in the string constant
pool.


---

### How many objects are created in Strings using string literals and new operator?

```
String s = "TEST" - 1 Object
String s = new String("TEST") - 2 Objects
```

---

### How string constant pool works?

A Java String Pool is a place in heap memory where all the strings defined in the program are stored. Whenever we create
a new string object, JVM checks for the presence of the object in the String pool, If String is available in the pool,
the same object reference is shared with the variable, else a new object is created.

[Check Usage](stringconstantpool/StringConstantPool.java)

When a new keyword is used to create the strings, Java creates it in a separate memory location and hence when comparing
s1 & s2 returns false.

When we use a literal to create the strings, JVM checks if the string is already present in the String Constant Pool
while creating s3. When it's not able to find it, it creates it in the pool. Now, when we initialized s4 with the same
value, upon checking for it in the pool, it finds it (s3), and references s4 to s3. Hence, when we compare s3 to s4, it
returns true.

---

### Difference between equals and == operator?

[Check Usage](stringconstantpool/StringConstantPool.java)

The string equals() method compares two strings and returns true if all characters match in both strings, else returns
false. The == operator compares the reference or memory location of objects in a heap, whether they point to the same
location or not.

---

### Difference between string, string buffer and string builder.

String is immutable whereas StringBuffer and StringBuilder are mutable classes. StringBuffer is thread-safe and
synchronized whereas StringBuilder is not. That's why StringBuilder is faster than StringBuffer.

---

# Objects

### Why is wrapper class required?

A wrapper class wraps (encloses) around a data type and gives it an object appearance. Wrapper classes are final and
immutable.

Feature:

* Wrapper Classes provides additional features over the primitive data types when it comes to usage. These methods
  include primarily methods like valueOf(), parseInt(), toString(), and many more.
* An object is needed to support synchronization in multithreading.
* Data structures in the Collection framework, such as ArrayList and Vector, store only objects (reference types) and
  not primitive types.

Boxing or AutoBoxing is the process of converting a primitive datatype into an object wrapper datatype, and unboxing is
the process of
converting a value from an object wrapper type back to the native primitive value.
---

### Methods of Object class?

Following are the methods present in the Object Class:

* **toString()** - This method obtains the object’s string representation, offering flexibility for customization.
* **hashCode()** - A hash code is a numeric value generated by a specific method known as a hashing algorithm. In Java,
  every object possesses a distinct and unique hash code. This code is derived by applying the algorithm to the internal
  address of the object.
* **equals()** - This method compares two objects and indicates whether they are equal or not.
* **get()** - Java’s get() function, associated with objects, retrieves the value of a designated field represented by a
  Field object.
* **finalize()** - The garbage collector triggers the finalize() method when removing an object from memory,
  specifically
  when there are no remaining references to that object.
* **clone()** - In a subclass that implements the Cloneable Interface, it is expected to override the clone() method of
  the
  Object class. This method is utilized for creating a clone, essentially a duplicate of the object along with its
  member variable values, using the syntax obj.clone(). If a class fails to implement the Cloneable interface,
  attempting this process results in a thrown CloneNotSupportedException.
* **wait()** - By using this technique, the current thread is made to wait for a notification from another thread.
  Within the function, you must provide the time in milliseconds for which the thread will remain in this waiting state.
* **notify()** - By using this technique, notifications are sent to a single thread at a time, waking it up while it is
  waiting for a certain item.
* **notifyAll()** - This function awakens all threads that are currently waiting for an object and sends notifications
  to all threads at the same time.

---

### Does java gives importance to primitive data types?

Java has a two-fold type system consisting of primitives such as int, boolean and reference types such as Integer,
Boolean. Every primitive type corresponds to a reference type.

Every object contains a single value of the corresponding primitive type. The wrapper classes are immutable (so that
their state can’t change once the object is constructed) and are final (so that we can’t inherit from them).

Variables of primitive types live in the stack and hence are accessed **fast**. For the details, we recommend our
tutorial
on the Java memory model whereas, The reference types are objects, they live on the heap and are relatively slow to
access.
They have a certain overhead concerning their primitive counterparts.

Default values of the primitive types are 0 (in the corresponding representation, i.e. 0, 0.0d etc) for numeric types,
false for the boolean type, \u0000 for the char type. For the wrapper classes, the default value is null.

Current Java language specification doesn’t allow usage of primitive types in the parametrized types (generics)

[More details from here](https://www.baeldung.com/java-primitives-vs-objects)

### Is Java pass by value or pass by reference?

Pass By Value - Java creates a copy of the variable being passed in the method and then do the manipulations.

[Example](javapassbyvalue/JavaPassByValue.java)

---

# OOPS

### Types of oops

* **Abstraction** - Abstraction is the process of hiding the internal details of an application from the outer world.
  Abstraction is used to describe things in simple terms. It’s used to create a boundary between the application and the
  client programs. In Java, abstraction is achieved by interfaces and abstract classes. We can achieve 100% abstraction
  using interfaces.

* **Encapsulation** - It refers to the bundling of data with the methods that operate on that data. Encapsulation is
  used to
  hide the values or state of a structured data object inside a class, preventing unauthorized parties' direct access to
  them.

* **Inheritance** - It is the mechanism in Java by which one class is allowed to inherit the features (fields and
  methods)
  of another class. We are achieving inheritance by using extends keyword. Inheritance is also known as “is-a”
  relationship.

* **Polymorphism** - The ability of objects to take on many forms. In other words, it allows different objects to
  respond to
  the same message or method call in multiple ways. Method Overloading & Method Overriding Are used to achieve this.

**Method Overriding:** In Java, method overriding occurs when a subclass (child class) has the same method as the parent
class. In other words, method overriding occurs when a subclass provides a particular implementation of a method
declared by one of its parent classes.

**Method Overloading:** Method overloading in Java means having two or more methods (or functions) in a class with the
same
name and different arguments (or parameters).
---

### Composition vs Aggregation vs Association?

If an object contains the other object and the contained object cannot exist without the existence of that object, then
it is called **composition**. It represents part-of relationship. In composition, both entities are dependent on each
other.

**Association** in Java is a connection or relation between two separate classes that are set up through their objects.
Association relationship indicates how objects know each other and how they are using each other's functionality. It can
be one-to-one, one-to-many, many-to-one, and many-to-many.

**Aggregation** is a type of association between classes in which one class (the whole or container) contains a
reference to another class (the part or component). Aggregation represents a “has-a” relationship, where one class
contains objects
of another class as part of its internal structure.

[Details & Examples Here](https://www.geeksforgeeks.org/association-composition-aggregation-java/)

---

### Difference between Abstract class and Interface?

**Abstract Class**

An abstract class is a class that cannot be instantiated on its own and may contain both abstract methods (without a
body) and concrete methods (with a body). Abstract classes are used to provide a common base class for other classes to
extend from.

Key Characteristics:

* Abstract Methods: Can have abstract methods that must be implemented by subclasses.
* Concrete Methods: Can have concrete methods with a body.
* Fields: Can have fields (variables) and constructors.
* Access Modifiers: Methods and fields can have different access modifiers (public, protected, private).
* Single Inheritance: A class can extend only one abstract class.

It is not mandatory to provide an access modifier to an abstract class. However, if you do not specify an access
modifier, the default access level will be package-private (i.e., accessible only within the same package).

**Interfaces**

An interface is a reference type in Java, similar to a class, that can contain only constants, method signatures,
default methods, static methods, and nested types. Interfaces cannot contain instance fields or constructors. Interfaces
are used to define a contract that other classes must follow.

Key Characteristics:

* Abstract Methods: All methods are implicitly abstract (except default and static methods).
* Default Methods: Can have default methods with a body.
* Static Methods: Can have static methods with a body.
* No Fields: Cannot have instance fields, but can have static final constants.
* Multiple Inheritance: A class can implement multiple interfaces.

By default, all the methods in an interface are public and abstract, and all the fields are public, static, and final

[Demo](abstractclassesandinterfaces)

---

### Can private method or static methods be overridden in Java?

No, we cannot override private or static methods in Java.

Private methods in Java are not visible to any other class which limits their scope to the class in which they are
declared.

If a method is declared as static, it is a member of a class rather than belonging to the object of the class. It can be
called without creating an object of the class. A static method also has the power to access static data members of the
class.

---

### Can main() method be overloaded?

Yes, we can overload the main() method in Java. A Java class can have any number of overloaded main() methods. But the
very first thing JVM (Java Virtual Machine) seeks is the original main() method, i.e., public static void main(String[]
args) to execute.

---

### Can Abstract Classes and Interfaces have main() ?

Abstract Classes can have main()

Interfaces has 2 answers :)

No you cannot, because main has to be static in order to be used as an entry point, and Interfaces don't allow the use
of static, till Java 7

Yes you can run a psvm in an interface, if you're working in Java 8. Because static methods are allowed in an interface
starting from Java 8.

# Serialization

### What is Serialisation and Deserialization?

Data **serialization** is the process of converting an object into a stream of bytes to more easily save or transmit it.

Constructing a data structure or object from a series of bytes is **deserialization**.

---

### Use of transient keyword?

The primary role of the transient keyword comes in cases of serialization. The transient modifier can be applied to
field members of a class to turn off serialization on these specific members.

---

### Is it possible to serialise a class if its super class is not serializable ?Can the class be still serialised and deserialize?

Yes provided that non-serializable super class has no args constructor which is involved at deserialization to
initialise the super class.

How it works ?

**Serialization of the Serializable Subclass:**

* When you serialize an instance of the subclass, only the fields declared in the subclass and the serializable parts of
  the object graph are serialized.
* The non-serializable superclass is not serialized, but its default (no-arg) constructor will be called during
  deserialization to initialize the state inherited from the superclass.

**Deserialization Process:**

* During deserialization, the non-serializable superclass is reinitialized using its default constructor.
* If the non-serializable superclass does not have a default constructor, deserialization will fail.

# Cloning

### What is marker interface?

An interface that does not contain methods, fields, and constants is known as marker interface. The Serializable and
Cloneable interfaces are the example of marker interface.

By introducing annotations, Java provided us with an alternative to achieve the same results as the marker interfaces.
Moreover, like marker interfaces, we can apply annotations to any class, and we can use them as indicators to perform
certain actions.

So what’s the key difference?

Unlike annotations, interfaces allow us to take advantage of polymorphism. As a result, we can add additional
restrictions to the marker interface.

---

### What is shallow copy and Deep copy?

Shallow Copy stores the references of objects to the original memory address. And so, Shallow Copy reflects changes made
to the new/copied object in the original object. Hence, A shallow copy is faster.

Deep copy truly clones the underlying data. It is not shared between the first and therefore the copy. Therefore, Deep
copy doesn’t reflect changes made to the new/copied object in the original object.

# Exception

### Errors vs Exceptions

Errors indicate unrecoverable system issues beyond program control. In contrast, exceptions represent unexpected events
within the program that can often be handled gracefully.

---

### Checked Vs Unchecked Exception

Checked exceptions represent errors outside the control of the program. For example, the constructor of FileInputStream
throws FileNotFoundException if the input file does not exist. Some common checked exceptions in Java are IOException,
SQLException and ParseException. Java verifies checked exceptions at compile-time.

If a program throws an unchecked exception, it reflects some error inside the program logic. For example, if we divide a
number by 0, Java will throw ArithmeticException. Java does not verify unchecked exceptions at compile-time.

---

### Create Custom Exception

[CreateCustomException](CreateCustomException.java)

---

### What is Runtime exception ?

A runtime exception is an error that occurs while a program is running. Unlike compile-time errors, which are caught by
the compiler before the program runs, runtime exceptions happen during the execution of the program. These exceptions
typically arise due to unexpected conditions or incorrect usage of programming constructs, such as dividing by zero,
accessing an array element out of bounds, or attempting to use a null reference.




